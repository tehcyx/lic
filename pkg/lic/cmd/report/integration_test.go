// Package report implements integration tests for the lic report command.
package report

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/tehcyx/lic/pkg/lic/core"
)

// TestIntegration_GoModProject tests the full workflow with a go.mod project
func TestIntegration_GoModProject(t *testing.T) {
	// Create temporary test project with go.mod
	tmpDir := t.TempDir()

	goModContent := `module example.com/testproject

go 1.24

require (
	github.com/spf13/cobra v1.8.1
	github.com/pelletier/go-toml v1.9.5
)
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil {
		t.Fatalf("Failed to create go.mod: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "testproject"
	opts.ProjectVersion = "1.0.0"

	err := opts.Run()
	// May have violations for non-whitelisted deps, which is okay
	if err != nil {
		t.Logf("Run() completed with error (possibly violations): %v", err)
	}
}

// TestIntegration_GopkgLockProject tests the full workflow with a Gopkg.lock project
func TestIntegration_GopkgLockProject(t *testing.T) {
	// Create temporary test project with Gopkg.lock
	tmpDir := t.TempDir()

	gopkgContent := `# This file is autogenerated

[[projects]]
  name = "github.com/spf13/cobra"
  version = "v1.8.1"
  revision = "abc123"

[[projects]]
  name = "github.com/pelletier/go-toml"
  version = "v1.9.5"
  revision = "def456"
`
	gopkgPath := filepath.Join(tmpDir, "Gopkg.lock")
	if err := os.WriteFile(gopkgPath, []byte(gopkgContent), 0644); err != nil {
		t.Fatalf("Failed to create Gopkg.lock: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "testproject"
	opts.ProjectVersion = "1.0.0"

	err := opts.Run()
	// May have violations for non-whitelisted deps, which is okay
	if err != nil {
		t.Logf("Run() completed with error (possibly violations): %v", err)
	}
}

// TestIntegration_GopathProject tests the full workflow with a GOPATH-style project
func TestIntegration_GopathProject(t *testing.T) {
	// Create temporary test project with Go files
	tmpDir := t.TempDir()

	goFileContent := `package main

import (
	"fmt"
	"github.com/spf13/cobra"
)

func main() {
	fmt.Println("test")
	_ = cobra.Command{}
}
`
	goFilePath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(goFilePath, []byte(goFileContent), 0644); err != nil {
		t.Fatalf("Failed to create main.go: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "testproject"
	opts.ProjectVersion = "1.0.0"

	err := opts.Run()
	// May have violations for non-whitelisted deps, which is okay
	if err != nil {
		t.Logf("Run() completed with error (possibly violations): %v", err)
	}
}

// TestIntegration_EmptyProject tests handling of a project with no dependencies
func TestIntegration_EmptyProject(t *testing.T) {
	// Create temporary empty project
	tmpDir := t.TempDir()

	goFileContent := `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}
`
	goFilePath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(goFilePath, []byte(goFileContent), 0644); err != nil {
		t.Fatalf("Failed to create main.go: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "emptyproject"
	opts.ProjectVersion = "1.0.0"

	err := opts.Run()
	if err != nil {
		t.Errorf("Run() should not error on empty project: %v", err)
	}
}

// TestIntegration_StdLibOnlyProject tests a project with only standard library imports
func TestIntegration_StdLibOnlyProject(t *testing.T) {
	// Create temporary project with only stdlib imports
	tmpDir := t.TempDir()

	goModContent := `module example.com/stdlibonly

go 1.24
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil {
		t.Fatalf("Failed to create go.mod: %v", err)
	}

	goFileContent := `package main

import (
	"fmt"
	"os"
	"encoding/json"
)

func main() {
	fmt.Println("Hello")
	os.Exit(0)
	json.Marshal(nil)
}
`
	goFilePath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(goFilePath, []byte(goFileContent), 0644); err != nil {
		t.Fatalf("Failed to create main.go: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "stdlibonly"
	opts.ProjectVersion = "1.0.0"
	opts.StdLib = true // Include stdlib in report

	err := opts.Run()
	if err != nil {
		t.Errorf("Run() should not error on stdlib-only project: %v", err)
	}
}

// TestIntegration_InvalidPath tests error handling for invalid paths
func TestIntegration_InvalidPath(t *testing.T) {
	tests := []struct {
		name    string
		srcPath string
	}{
		{
			name:    "non-existent path",
			srcPath: "/nonexistent/path/that/does/not/exist",
		},
		{
			name:    "empty directory",
			srcPath: t.TempDir(), // Empty directory with no Go files
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			opts := NewGolangReportOptions(core.NewOptions())
			opts.SrcPath = tt.srcPath
			opts.ProjectName = "invalidproject"
			opts.ProjectVersion = "1.0.0"

			err := opts.Run()
			// Empty directory might not error, but non-existent path should
			if tt.name == "non-existent path" && err == nil {
				t.Error("Run() should error for non-existent path")
			}
		})
	}
}

// TestIntegration_WhitelistedDomains tests that whitelisted domains are properly validated
func TestIntegration_WhitelistedDomains(t *testing.T) {
	tmpDir := t.TempDir()

	goModContent := `module example.com/whitelisted

go 1.24

require (
	github.com/spf13/cobra v1.8.1
	golang.org/x/oauth2 v0.24.0
	gopkg.in/yaml.v2 v2.4.0
)
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil {
		t.Fatalf("Failed to create go.mod: %v", err)
	}

	// Run the report command
	opts := NewGolangReportOptions(core.NewOptions())
	opts.SrcPath = tmpDir
	opts.ProjectName = "whitelisted"
	opts.ProjectVersion = "1.0.0"

	err := opts.Run()
	// All these domains are whitelisted, should not have violations
	if err != nil {
		t.Logf("Run() completed with error: %v", err)
	}
}
